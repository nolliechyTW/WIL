# Content
- Prefer Types That Always Represent Valid States
- Be Liberal in What You Accept and Strict in What You Produce
- Don’t Repeat Type Information in Documentation
- Avoid Including `null` or `undefined` in Type Aliases
- Push Null Values to the Perimeter of Your Types
- Prefer Unions of Interfaces to Interfaces with Unions
- Prefer More Precise Alternatives to String Types
- Use a Distinct Type for Special Values
- Limit the Use of Optional Properties
- Avoid Repeated Parameters of the Same Type
- Prefer Unifying Types to Modeling Differences
- Prefer Imprecise Types to Inaccurate Types
- Name Types Using the Language of Your Problem Domain
- Avoid Types Based on Anecdotal Data

## Prefer Types That Always Represent Valid States
## Be Liberal in What You Accept and Strict in What You Produce
## Don’t Repeat Type Information in Documentation
## Avoid Including `null` or `undefined` in Type Aliases
## Push Null Values to the Perimeter of Your Types
## Prefer Unions of Interfaces to Interfaces with Unions
## Prefer More Precise Alternatives to String Types
## Use a Distinct Type for Special Values
## Limit the Use of Optional Properties
## Avoid Repeated Parameters of the Same Type
## Prefer Unifying Types to Modeling Differences
## Prefer Imprecise Types to Inaccurate Types
## Name Types Using the Language of Your Problem Domain
## Avoid Types Based on Anecdotal Data